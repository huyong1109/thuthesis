\chapter{海洋模式正压求解器}
\label{cha:barosSolver}

\section{本章概述}

\section{背景和动机}
\label{sec:baroBackgroud} 
为了完整的推导我们的新的P-CSI求解器，这里我们简要的描述一下海洋模式POP中的控制方程。
海洋模式中的原始动量和连续性方程可以表达如下：
\begin{align}
&\frac{\partial }{\partial t} \textbf{u} +\mathcal{L}(\textbf{u}) + f\times \textbf{u} = - \frac{1}{\rho_0}\nabla p +F_H(\textbf{u}) +F_V(\textbf{u}) \label{eq:momen}\\
&\mathcal{L}(1) = 0 \label{eq:continuous}
\end{align}
这里$\mathcal{L}(\alpha ) = \frac{\partial }{\partial x} (u\alpha)  +\frac{\partial }{\partial y} (v\alpha) +\frac{\partial }{\partial z} (w\alpha)$， 它在$\alpha =1$时与平流算子等价， $x，y，z$ 分别是水平和垂直坐标变量， $\textbf{u} = [u，v]^T$ 水平速度向量， $w$ 垂直速度， $f$ 表示科氏力系数，  $p$ 和 $\rho_0$ 分别表示压力和密度， $F_H$ 和 $F_V$分别表示水平和垂直耗散项 \citep{smith2010parallel}。  
为了求解这个三维的原始方程，海洋模式分量将时间积分分解为两个模态。 一个是求解三维动力学和热动力学过程的斜压模态，另一个则是求解二维海表高度（SSH）的变化。

%----------------------------------------------------------------------------
\subsection{正压模态} \label{se:baro_mode}


  
在静力平衡近似条件下，POP中海底深度为$z$的位置上的压力可以分解为两个部分：  
\begin{align}
\displaystyle p = p_h + p_s = \int^0_z g\rho dz +p_s
\end{align}
这里$p_h$表示静力平衡压力，$p_s$表示由于海表自由面波动而引起的海表压力。 
正压模态的控制方程是由原始动量方程和连续性方程(\ref{eq:momen}，\ref{eq:continuous}) 从海洋底部到海洋表面垂直积分而得到的:
\begin{align}
&\displaystyle \frac{\partial \textbf{U} }{\partial t}  = -g \nabla \eta + F  \label{eq:baro_mon}\\
&\displaystyle \frac{\partial \eta }{\partial t} = - \nabla \cdot H\textbf{U} + q_w  \label{eq:baro_con}
\end{align}
这里  $\textbf{U} =  \frac{1}{H+\eta}\int_{-H}^\eta dz \textbf{u}(z) \approx \frac{1}{H }\int_{-H}^0 dz \textbf{u}(z)$是正压速度的垂直积分，
$\eta = p_s/{\rho_0g}$是海表高度，$H$是海洋底部的深度，$q_w$单位海表面积的活水通量，$g$表示由于地球动力引起的加速度而$F$表示对海洋动量方程中除了与时间趋势和海表压力梯度相关的所有项做垂直积分所得到的量（参见方程\ref{eq:momen}）。
 
垂直方向上的边界条件是
\begin{align}
\label{eq:bound_w}
w = \left\{ \begin{array}{ll}
\frac{\partial}{\partial t} \eta  +\textbf{u}\cdot\nabla \eta - q_w, & z = \eta  \\
0, & z = -H
\end{array} \right.
\end{align}
 
值得一提的是，为了简化求解过程，正压连续性方程 (\ref{eq:baro_con}) 中忽略掉了边界条件中的小项 $\nabla \eta$\citep{smith2010parallel}。
为了能够使用更长的时间步长，海洋模式分量的正压模态中采用了隐式格式，并且将椭圆方程简化成一个线性系统。 通过时间差分，方程  (\ref{eq:baro_mon})和(\ref{eq:baro_con}) 可化为
\begin{align}
&\displaystyle \frac{ \textbf{U}^{n+1} - \textbf{U}^{n-1}}{\tau}  = -g \nabla \eta + F \label{eq:udt} \\
&\displaystyle \frac{\eta^{n+1} - \eta^n }{\tau}  = - \nabla \cdot H\textbf{U} + q_w \label{eq:etadt}
\end{align}
这里 $\tau$ 与差分格式相关的时间步长。 
用方程（\ref{eq:udt}）中下一时刻的正压速度来替换方程（\ref{eq:etadt}）中的正压速度， 就得到了一个关于海表高度$\eta$的椭圆系统
\begin{equation}
\label{eq:sshdiscret}
     [-\nabla\cdot H \nabla + \frac{1}{g  \tau^2}]\eta^{n+1}
           = -\nabla\cdot H[\frac{\textbf{U}^{n-1}}{g \tau} + \frac{F}{g}] + \frac{\eta^n}{g\tau^2} +\frac{q_w}{g\tau}
\end{equation}
 
为了简单，我们将椭圆方程（\ref{eq:sshdiscret}）重新标记为
\begin{equation}
\label{eq:ssh}
[-\nabla \cdot H\nabla +\frac{1}{g  \tau^2}]\eta^{n+1} = \psi(\eta^n,\eta^{n-1},\tau)
\end{equation}
这里 $\psi$表示一个关于当前时刻和上一时刻$\eta$状态的函数。
 

\begin{figure}[!htbp]
\centering
\includegraphics[width=12cm, height=6.5cm]{grid_domain.pdf}
\caption[] {海洋模式分量中网格划分\label{fig:grid1}}
\end{figure}

\begin{figure}[!htbp]
\centering
\includegraphics[ height=10cm]{EvpBug_fix_gmd_new}
\caption[] {0.1度海洋模式POP的海表盐度。 \label{fig:sst}}
\end{figure}

如图\ref{fig:grid1}所示， POP采用在水平方向上采用Arakawa B网格\citep{smith2010parallel}，并且采用九点差分格式对方程（\ref{eq:ssh}）进行离散。得到如下离散格式：
\begin{align}
    & \nabla\cdot H \nabla \eta  =\frac{1}{\Delta y}\delta_x \overline{[\Delta y H  \delta_x\overline{\eta}^y]}^y +\frac{1}{\Delta x}\delta_y \overline{[\Delta x H  \delta_y\overline{\eta}^x]}^x \label{eq:nabla2}
  \end{align}

这里 $\Delta_\xi$和$\delta_\xi$  （$\xi \in \{x， y\} $）分别为有限差分和它们相应的偏导，  $\delta_\xi (\cdot) $和$\overline{(\cdot)}^\xi $ 分别表示有限差分算子和平均算子。  
\begin{align}
&\delta_\xi \psi = [\psi (\xi+\Delta_\xi/2) -\psi(\xi-\Delta_\xi/2)]/\Delta_\xi \\
&\overline{\psi}^\xi  =[\psi (\xi+\Delta_\xi/2) +\psi(\xi-\Delta_\xi/2)]/2
\end{align}
%----------------------------------------------------------------------------


为了避免极点问题，POP采用偏移的或者三极点的广义正交网格。这使得方程的系数非常的繁杂。
为了能够简单而不失偏颇，我们将给出系数矩阵在均匀的网格和给定的不变的海底深度$H$的情况下的显式表达式。
 

表达式\ref{eq:nabla2}此时为
\begin{align}
 [\nabla\cdot H \nabla \eta]_{i,j}&= -\frac{H}{S_{i,j}}(A_{i,j}^O\eta_{i,j}+A_{i,j}^{NW}\eta_{i-1,j+1}+A_{i,j}^N\eta_{i,j+1} +A_{i,j}^{NE}\eta_{i+1,j+1}+A_{i,j}^W\eta_{i-1,j}  \nonumber\\
& +A_{i,j}^E\eta_{i+1,j} +A_{i,j}^{SW}\eta_{i-1,j-1} +A_{i,j}^S\eta_{i,j-1}+ A_{i,j}^{SE}\eta_{i+1,j-1})
\end{align}
这里$S_{i,j}  = \Delta x\Delta y$， $A_{i,j}^{\chi } ( \chi \in \mathcal{Q} = \{NW,NE, SW, SE, W, E, N, S\})$ 分别表示网格点 $(i,j)$和它自己、以及它的邻居点之间的在 九点差分格式中的系数（\ref{eq:nabla2}）。 这些系数由$\Delta x$， $\Delta y$， $\tau$和$H$决定。
\begin{equation} \label{defineA}
\begin{aligned}
&\alpha  = \frac{ \Delta y}{ \Delta x }, \quad \beta  = 1/\alpha \\
&A_{i,j}^{NW} = A_{i,j}^{NE} =A_{i,j}^{SW} = A_{i,j}^{SE} = - (\alpha  +  \beta  )/4 \\
&A_{i,j}^{W} = A_{i,j}^{E} = (  \beta  -\alpha  )/2 \\
&A_{i,j}^{N} = A_{i,j}^{S} = (\alpha  -\beta )/2 \\
&A_{i,j}^{O} =   \alpha   +\beta  \\
\end{aligned}
\end{equation}


%&\alpha_1 = \frac{2\Delta y}{2\Delta x_j +\Delta x_{j+1}2}\\
%& \alpha_2= \frac{2\Delta y}{ \Delta x_j +\Delta x_{j-1}  } \\
%&\alpha_3 = \frac{\Delta y(\Delta x_{j-1}+2\Delta x_j +\Delta x_{j+1})}{2 (\Delta x_j +\Delta x_{j-1})(\Delta x_j +\Delta x_{j+1})} \\
%& \beta_1 = \frac{(\Delta x_j +\Delta x_{j+1})}{8 \Delta y} \\
%& \beta_2 = \frac{(\Delta x_j +\Delta x_{j-1})}{8 \Delta y} \\
%& \beta_3 = \frac{(\Delta x_{j-1}+2\Delta x_j +\Delta x_{j+1})}{8 \Delta y} \\
%&A_{i,j}^{NW} = A_{i,j}^{NE} = \alpha_1 + \beta_1 \\
%&A_{i,j}^{SW} = A_{i,j}^{SE} = \alpha_2 +  \beta_2 \\
%&A_{i,j}^{W} = A_{i,j}^{E} = \alpha_3 - 2 \beta_3 \\
%&A_{i,j}^{N} = -2\alpha_1  + 2 \beta_1 \\
%&A_{i,j}^{S} = -2\alpha_2  + 2 \beta_2  \\
%&A_{i,j}^{O} = -2\alpha_3  -4 \beta_3  \\
%Then， the coefficients between the given point $(i,j)$和its other neighbors can be computed from $A^n$， $A^e$和$A^{ne}$ on its neighbors。
方程\ref{eq:ssh}在给定点$(i,j)$上的离散格式则可以表示为  
\begin{align}
\label{eq:sten}
&(A_{i,j}^O+\phi ) \eta_{i,j}+A_{i,j}^{NW}\eta_{i-1,j+1}+A_{i,j}^N\eta_{i,j+1} +A_{i,j}^{NE}\eta_{i+1,j+1}+A_{i,j}^W\eta_{i-1,j}  \nonumber\\
& +A_{i,j}^E\eta_{i+1,j} +A_{i,j}^{SW}\eta_{i-1,j-1} +A_{i,j}^S\eta_{i,j-1}+ A_{i,j }^{SE}\eta_{i+1,j-1}= \frac{S_{i,j}}{H}\psi_{i,j}
\end{align}
这里$\phi = \frac{S_{i,j}}{g  \tau^2H}$ 是与单位网格大小、海底深度和时间步长有关的一个变量。

\begin{figure}[!htbp]
\centering
\includegraphics[height=6.5cm]{SparsePatternSample}
\caption[] {大小为$30\times 15$的网格上所得到的系数矩阵的稀疏模式。 \label{fig:spy}}
\end{figure}
因此椭圆方程(\ref{eq:sshdiscret})就变成了关于$\eta$的一个线性方程组，也就是 $Ax= b$。 其中$A$表示由系数 $A^*$构成的快对角矩阵。
方程 \ref{defineA}和 \ref{eq:sten}表明$A$是有水平网格大小、海底深度和时间步长决定。 
他们之间具体的关系将在第\textbf{ref}节中深入讨论。
%In the POP， only the nonzero elements are stored。
方程(\ref{eq:sten})同时还表明 $A$ 每一行只有九个非零元素， 也就是说$A$是一个系数矩阵。 图\ref{fig:spy}展示了$A$的稀疏模式。


\section{海洋模式正压模态求解器}
\label{sec:baro1}
方程(\ref{eq:ssh})在二维广义正交网格上使用九点差分格式进行离散。  
POP将全球区域划分为若干个小块，并将这些块分发给每一个进程。
每个进程只负责计算它所分得的块内网格点上的迭代过程，并且维护一个与周围进程进行数据交换的边界区域。 
我们假设全球区域上的网格大小为$\mathcal{N}\times
\mathcal{N}$且被划分为$m\times m$ 个大小为$n\times n$ ($n=\mathcal{N}/m$)的小块.
我们定义$B$ 和 $\tilde{x}$ 分别为与给定块相对应系数矩阵（也就是 $A$的一个大小为 $n^2\times n^2$的子矩阵)和向量。
这个块上的子矩阵和子向量的乘积操作$B\tilde{x}$ 需要$9n^2$ 次计算 \cite{hu2013scalable}.
%----------------------------------------------------------------------------
\subsection{ChronGear求解器}
\begin {figure}[!t]
%\vspace{-5pt}
\centering
\includegraphics[height=6.5cm]{newPOPStepComp}
\caption[] {0.1度POP采用默认的对角预处理的ChronGear求解器时个分量耗时的百分比。\label{fig:StepComp}}
\end{figure}

ChronGear \cite{dAzevedo1999lapack} 是一种修正过的共轭梯度法，它将每一步迭代过程中的两次全局通信组合成一次。
然而，如前面提到的，当成千上万个处理器核心被用来计算高分辨（比如0.1度）的POP时，ChronGear算法中计算內积所需要的全局通信操作仍然是一个严重的瓶颈。
这个瓶颈对0.1度POP的影响可以通过图\ref{fig:StepComp} 看出来。线性求解器的计算时间占总时间的比例随着所使用的处理器核心数的增大而增加。
当只使用470个处理器核心时，正压求解器的执行时间只占到整个POP的运行时间的5\% （这里不考虑初始化和 I/O时间），而此时斜压模态的运行时间却占总运行时间的90\%左右。
然而，当使用数千个处理器核心时，斜压模态所消耗的计算时间占总时间的比例会逐渐下降，而正压求解器所占的比例却在不断增加。
当使用1万6千多处理器核心时，正压求解的计算时间占中运行时间的比例高达50\%。 

\begin{algorithm}[!t]
\caption{Chronopoulos-Gear求解器}
\label{alg:pcg}
%\begin{scriptsize}
\begin{algorithmic}[1]
\REQUIRE   与网格快$B_{i,j}$相应的系数矩阵$\textbf{B}$, 预处理子 $\textbf{M}$, 初始解 $\textbf{x}_0$ 和 $\textbf{b}$  \\
//\qquad    \textit{do in parallel with all processes}
\STATE $\textbf{r}_0 = \textbf{b}-\textbf{B}\textbf{x}_0$, $\textbf{s}_0 =0$, $\textbf{p}_0 =0$;\quad $\rho_0=1$,$\sigma_0=0$, $k=0$;
\WHILE{$k \leq k_{max}$ }
\STATE $k=k+1$;
\STATE $\textbf{r}'_{k} =\textbf{M}^{-1}\textbf{r}_{k-1}$; \label{pcg_scale0} \COMMENT{preconditioning}
\STATE $\textbf{z}_k = \textbf{B}\textbf{r}'_{k}$; \label{pcg_mat}\COMMENT {matrix-vector multiplication}
\STATE $update\_halo(\textbf{z}_{k})$; \COMMENT{boundary communication} \label{pcg_bc1}
\STATE $\tilde{\rho_k} = \textbf{r}_{k-1}^T\textbf{r}'_{k}$;\label{pcg_dot1}
\STATE $\tilde{\delta_k} = \textbf{z}_k^T\textbf{r}'_k$;\label{pcg_dot2}
\STATE $(\rho_k,\delta_k) = global\_sum(\tilde{\rho_k},\tilde{\delta_k})$;\label{pcg_global1} \COMMENT{global reduction}
\STATE $\beta_k = \rho_k / \rho_{k-1}$;\label{pcg_beta}
\STATE $\sigma_k = \delta_k - \beta_k^2\sigma_{k-1}$;\label{pcg_sigma}
\STATE $\alpha_k = \rho_k /\sigma_{k}$;\label{pcg_alpha}
\STATE $\textbf{s}_k = \textbf{r}'_{k} +\beta_k\textbf{s}_{k-1}$;\label{pcg_scale1}
\STATE $\textbf{p}_k = \textbf{z}_{k} +\beta_k\textbf{p}_{k-1}$;\label{pcg_scale2}
\STATE $\textbf{x}_k =\textbf{x}_{k-1} +\alpha_k \textbf{s}_k$;\label{pcg_scale3}
\STATE $\textbf{r}_k =\textbf{r}_{k-1} -\alpha_k\textbf{p}_k$;\label{pcg_scale4}
\STATE $convergence\_check(\textbf{r}_{k})$;  \COMMENT{check convergence}
\IF{ $k \% n_{c} == 0$}
\STATE \textbf{if} $||\textbf{r}_k|| \le \epsilon$  \textbf{return} ;\COMMENT{每 $n_c$ 检查一次是否收敛}
\ENDIF
\ENDWHILE
\end{algorithmic}
%\end{scriptsize}
\end{algorithm}

我们给出ChronGear方法的具体算法
\ref{alg:pcg}， 以供参考.  ChronGear主要包括三个部分：计算部分，边界通信部分和全局通信部分。
计算部分主要包括矩阵向量乘操作，向量向量乘操作以及向量的伸缩操作（向量与常数相乘）等具有很好的可扩展性的操作。 
边界通信会在每次矩阵向量乘操作之后被调用，其开销随着计算使用的处理器核心数的增加和减少，但是有一个下界。 
但是，我们后面的章节将会证明，每一步迭代过程中的內积操作\ref{pcg_global1}之后需要调用的全局通信，当使用很大的核心数时，将会成为可扩展性的瓶颈。
 

%----------------------------------------------------------------------------
\subsection{通信瓶颈}\label{se:bottleneck}
  
假设使用$p=m^2$个进程，每一个进程恰好分得一个网格块（这在高分辨率POP中是比较常见的配置）。 
这是正压模态的总运行时间就等于ChronGear求解器在每一个块上的运行时间。 
我们记求解器的每一次迭代过程中，计算、边界通信和全局通信操作的耗时分别为$\mathcal{T}_c$，$\mathcal{T}_b$ 和$\mathcal{T}_g$。 
%----------------------------------------------------------------------------


从算法\ref{alg:pcg}中可以得出, 计算开销
$\mathcal{T}_c$主要涉及到四个向量伸缩操作 (算法中步骤\ref{pcg_scale1}, \ref{pcg_scale2} ,\ref{pcg_scale3}, 和
\ref{pcg_scale4}), 两个向量向量乘积操作或內积操作 (算法中步骤\ref{pcg_dot1} 和 \ref{pcg_dot2}), 以及一个矩阵向量乘积操作 (算法步骤\ref{pcg_mat}).  
因此,$\mathcal{T}_c= (4 n^2 +2n^2+ 9n^2)\theta + \mathcal{T}_{p}=15\frac{\mathcal{N}^2}{p}\theta+\mathcal{T}_{p}$，
这里$\theta$ 表示单位时间内浮点操作的次数，$\mathcal{T}_{p}$ 表示预处理的开销。
比如，当采用对角预处理时，$\mathcal{T}_{p} =\frac{\mathcal{N}^2}{p}\theta$。
上面的定义可以看出，当计算核心数增加时，$\mathcal{T}_c$减少，并且以零为下界。

 
当调用了像矩阵向量乘和除了对角预处理以外的预处理等需要一层或一层以上的边界区域的操作时，在每个进程的边界区域上需要进行边界更新操作。 
由于在海洋模式POP中，每个进程都维护着它自己的块以外的两个边界层，因此，即使使用了非对角的预处理，每次迭代过程中仍只需要进行一次边界通信。
边界通信的实际开销取决于网络延迟和边界区域的大小。 当边界区域的层数为2时（这也是POP中的默认配置）， 边界区域的每个边的大小为$2n$ ，而且这个大小会随着进程数的增大而变小。 
 
因此，每一步迭代中，边界通信的时间复杂度为$\mathcal{T}_b =4\alpha +(4\times 2n)\beta=4\alpha +(\frac{8\mathcal{N}}{\sqrt{p}})\beta $这里$\alpha$ 表示单条点对点通信消息的延迟，而
$\beta$ 表示从网络中传输一比特需要的时间 (也就是网络带宽的倒数).
边界更新所需要的时间也是随着就算进程的增多而减少，但是有一个下界$4\alpha$。 


 
ChronGear求解器的每一步迭代中仅仅包含了一次全局归约操作。全局规约操作主要由一次MPI\_allreduce和一个去除路地网格点的掩盖操作，因此全局归约操作的开销满足$\mathcal{T}_g= 2\frac{\mathcal{N}^2}{p}\theta + \log p \alpha$ （假设网络采用二叉树结构）。 
路地点的掩盖操作的开销会随着进程数$p$的增大而减小，而MPI\_allreduce的开销将会一直随着进程数的增加而增大。 
注意到每次全局归约操作实际上近似于没有数据的交换，因为每个进程只传递了两个数值。
因此，全局通信的开销主要取决于网络的延迟而不是网络的传输速率。
结合以上三个部分，使用对角预处理的ChronGear求解器求解一次所需要的时间开销为：
\begin{eqnarray}
%\begin{tabular}{l}
\label{t_pcg}
&\mathcal{T}_{cg}=\mathcal{K}_{cg} (\mathcal{T}_c + \mathcal{T}_b+\mathcal{T}_g )\nonumber \\
&=\mathcal{K}_{cg} [18 \frac{\mathcal{N}^2}{p}\theta + \frac{8\mathcal{N}}{\sqrt{p}}\beta +(4+\log p)\alpha]
%\end{tabular}
\end{eqnarray}
这里 $K_{cg}$ 表示算法达到指定收敛条件所需要的迭代次数。
这个迭代次数不会随着进程数的增加而改变 \cite{hu2013scalable}。 
方程\ref{t_pcg}）表明，计算和边界更新所需要的时间开销都会随着进程数的增加而减少。 
但是，全局归约操作的时间开销则会随着进程数的增多而增加。 
因此，我们可以预测到，当进程数操作某一个值时， ChronGear求解器的运行时将会增加。 
图 \ref{fig:ChronGearCOMP}给出了在美国国际大气研究中心的黄石超级计算（详情见节\ref{se:exp}）上，运行一个模拟天时，ChronGear求解器的全局通信和边界通信两个部分的耗时分析。 
这里我们可以看到，当使用数千个处理器核心时，全局归约操作的时间变成了整个求解器耗时的主要部分，并且这个时间还在继续增大。 
 


\begin{figure}[!t]
%\vspace{-10pt}
\begin{center}
	\includegraphics[height=6.5cm]{newChronGear_comp.eps}
\caption[] {在美国黄石超级计算机上，0.1度POP的全局归约操作和边界更新操作占模拟一天总时间开销的比例。}
\label{fig:ChronGearCOMP}
\end{center}
\end{figure}
 

\section{CSI迭代法}
\label{sec:barocsi}

为了提高海洋模式POP的可扩展性，一个好的正压模态求解器应该具备的特点是需要尽可能少的全局归约操作。 
在文章\cite{hu2013scalable}中，胡勇等人提出了一个基于Stiefel的CSI方法的求解器。这个求解器被现在了单独版本的POP中。 
这里，我们将通过添加一个预处理的结构，进一步改进CSI方法。
这个改进后的方法我们称之为P-CSI方法。 我们将这个方法实现在地球系统模式CESM框架下的海洋模式分量POP中。 
早在1985年， Saad 等人\cite{saad1985solving}将传统的CSI的方法应用于向量机上，并且指出当方程中矩阵的特征值已知的条件下， 这种方法比共轭梯度法更适用于某些并行情况。 


P-CSI算法和它的性质与CSI方法相似，只是多加了一个预处理接口（将在下一章详细讨论）。 
值得一提的是，P-CSI方法与CSI方法一样，在每一步迭代过程中不需要做內积操作， 因此它即使在大核数上也能够保持较好的可扩展性。
为海洋模式POP设计的P-CSI求解器的伪码在算法\ref{alg:ppsi}中。
使用对角预处理的P-CSI方法的每一步迭代的计算时间为$T_c =\frac{12\mathcal{N}^2}{p}\theta+\mathcal{T}_p =\frac{13\mathcal{N}^2}{p}\theta$， 
而P-CSI求解器的总运行时间为如下
\begin{eqnarray}
\label{t_psi}
\mathcal{T}_{pcsi} = \mathcal{K}_{pcsi}(\mathcal{T}_c + \mathcal{T}_b ) \nonumber \\
= \mathcal{K}_{pcsi}[13\frac{\mathcal{N}^2}{p}\theta+ 4\alpha + \frac{8\mathcal{N}}{ \sqrt{p}}\beta]
\end{eqnarray}
这里$K_{pcsi}$ 表示P-CSI方法收敛到给定条件时所需要的迭代步数。 
\begin {figure}[!t]
\begin{center}
\includegraphics[height=6.5cm]{solver_iteration}
\caption []{1度POP中，Lanczos方法的迭代次数对P-CSI迭代步数的影响。 \label{fig:iter}}
\end{center}
\end {figure}

\begin{algorithm}[!t]
\caption{ 预处理的传统Stiefel迭代算法}
\label{alg:ppsi}
%\begin{scriptsize}
\begin{algorithmic}[1]
\REQUIRE 与网格块$B_{i,j}$相对应的系数矩阵 $\textbf{B}$, 预处理子$\textbf{M}$, 初始值$\textbf{x}_0$和方程右端向量$\textbf{b}$ ；预估的特征值区间$[\nu,\mu]$;  \\
 // \qquad    \textit{所有进程并行执行}
\STATE $\alpha =\frac{2}{\mu -\nu}$, $ \beta = \frac{\mu +\nu}{\mu -\nu}$, $\gamma = \frac{\beta}{\alpha}$, $\omega_0 =\frac{ 2}{\gamma}$;\quad $k = 0$;
\STATE $\textbf{r}_0 = \textbf{b}-\textbf{B}\textbf{x}_0$; $\Delta \textbf{x}_{0} = \gamma^{-1}\textbf{M}^{-1}\textbf{r}_0$; $\textbf{x}_1 =\textbf{x}_0 +\Delta \textbf{x}_{0}$; $\textbf{r}_1 =\textbf{b} -\textbf{B}\textbf{x}_1$;
\WHILE{$k \leq k_{max}$ }
\STATE $k=k+1$;
\STATE $\omega_k = 1/(\gamma - \frac{1}{4\alpha^2}\omega_{k-1})$; \COMMENT{迭代函数}
\STATE $\textbf{r}'_{k} =\textbf{M}^{-1}\textbf{r}_{k}$; \COMMENT{预处理} \
\STATE $\Delta \textbf{x}_{k} =\omega_k\textbf{r}'_{k}+(\gamma \omega_k-1)\Delta \textbf{x}_{k-1}$;
\STATE $\textbf{x}_{k+1} =\textbf{x}_{k}+\Delta \textbf{x}_{k}$;
\STATE $\textbf{r}_{k+1} =\textbf{b}- \textbf{B}\textbf{x}_{k+1}$; \COMMENT{矩阵向量乘}
\STATE $update\_halo(\textbf{r}_{k+1})$; \COMMENT{边界通信}
\IF{ $k \% n_{c} == 0$}
\STATE \textbf{if} $||\textbf{r}_{k+1}|| \le \epsilon$  \textbf{return} ;\COMMENT{每 $n_c$ 检查一次是否收敛}
\ENDIF
\ENDWHILE
\end{algorithmic}
%\end{scriptsize}
\end{algorithm}

\subsection{特征值估计}
\label{sec:barocsi}
P-CSI需要对预处理后的系数矩阵$M^{-1}A$的最大特征值$\mu$和最小特征值$\nu$进行估计。 
海洋模式POP中的系数矩阵$A$ 和它的对角预处理矩阵$M = \Lambda(A)$都是实对称矩阵， 因此预处理后的矩阵的最小最大特征值并不难估计。 
论文\cite{hu2013scalable} 中给出$A$的特征值的估计，这里我们采用Lanczos方法\cite{Paige1980235}来对$M^{-1}A$的最大最小特征值进行估计。
实验中，我们发现将Lanczos方法的收敛条件因子$\epsilon$ 设成$0.15$在不同的分辨率（1度或者0.1度）以及不同的预处理子（单位阵预处理、对角预处理和EVP预处理）的情况下都能达到较好的效果。 
图\ref{fig:iter} 可以看出只需要很少的Lanczos步骤就可以估计出比较恰当的$M^{-1}A$的最大最小特征值，从而使得P-CSI方法能够在较短的迭代步数内收敛。
在实际运行中，我们发现Lanczos方法的开销与调用数次ChronGear求解的开销相当。 

与ChronGear的迭代过程相比，P-CSI除了做收敛性检查之外不需要任何的全局归约操作。 
我们注意到，为了达到相同的收敛条件，P-CSI算法需要的迭代步骤比ChronGear的略多($K_{pcsi} > K_{cg}$)。 
以上的两点现象，我们可以解读出来，在当并行使用的处理器核心数比较小的时候，P-CSI应该会比ChronGear的开销更大一些。
因为处理器核心较少的时候，全局归约操作的开销并不算大。 
但是，当采用高分辨的网格时，需要用到更多的处理器核心，这是P-CSI的每一步迭代的开销应该会比ChronGear的要明显的快一些（参见公式\ref{t_pcg})和
(\ref{t_psi}）。
而这将进一步减少P-CSI算法到达收敛的时间。 

当满足条件$\nu = \lambda_{min}$和$\mu =\lambda_{max}$时，P-CSI的收敛速度将达到最优值。 
但是$\lambda_{min}$和$\lambda_{max}$是比较难以估计的。
更重要的是，我们不能对系数矩阵$A$随意的做变换，因为 $A$ 是分布在各个进程上的。
为了能够利用POP的并行特性，我们使用Lanczos方法来构造 出一系列三对角矩阵$T_m (m=1,2,...)$，这些矩阵的最大最小特征值逐渐的向$M^{-1}A$的最大最小特征值逼近。
To utilize the parallelism of POP, we employ Lanczos method  to construct
实际运行中, 我们发现合适的选择Lanczos迭代的步数，我们能够得到对最大最小特诊一个比较好的估计，这个估计值能够使得P-CSI方法与预处理共轭梯度法有相近的收敛速度。  


\begin{algorithm}[!ht]
\caption{基于Lanczos方法的针对预处理矩阵的特征值估计方法}
\label{alg:lanczos_pre}
\begin{algorithmic}[1]
\REQUIRE 网格块$B_{i,j}$ 的系数矩阵$\textbf{B}$，预处理子$\textbf{M}$和随机向量$\textbf{r}_0$； \\
 //\qquad    \textit{所有进行并行执行}
\STATE $\textbf{s}_0=\textbf{M}^{-1}\textbf{r}_0$;\quad $\textbf{q}_1 = \textbf{r}_0/({\textbf{r}_0^T\textbf{s}_0})$;\quad $\textbf{q}_0=\textbf{0}$;
\STATE $T_0=\emptyset$;\quad $\beta_0 =0$;\quad  $\mu_0 =0$;\quad $j=1$;
\WHILE{$j<k_{max}$}
\STATE $\textbf{p}_j = \textbf{M}^{-1}\textbf{q}_j$; \quad $\textbf{r}_j=\textbf{B}\textbf{p}_j-\beta_{j-1}\textbf{q}_{j-1}$;
\STATE $update\_halo(\textbf{r}_j)$;
\STATE $\tilde{\alpha}_j =\textbf{p}_j^T\textbf{r}_j$; \quad $\alpha_j=global\_sum(\tilde{\alpha}_j)$;
\STATE $\textbf{r}_j=\textbf{r}_j-\alpha_{j}\textbf{q}_{j}$; \quad $\textbf{s}_j = \textbf{M}^{-1}\textbf{r}_j$;
\STATE $\tilde{\beta}_j = \textbf{r}_j^T\textbf{s}_j$; \quad $\beta_j=sqrt(global\_sum(\tilde{\beta}_j))$;
\STATE \textbf{if} $\beta_j == 0$ \textbf{then} \textbf{return}
\STATE $\mu_j = max(\mu_{j-1},\alpha_j+\beta_j+\beta_{j-1})$; \label{lan_gersh}\\
\STATE $T_j=tri\_diag(T_{j-1},\alpha_j,\beta_j)$; \COMMENT{三对角矩阵}\label{lan_tm}
\STATE $\nu_j = eigs(T_j,'smallest')$ ; \label{lan_nu}
\STATE \textbf{if} $|\frac{\mu_j}{\mu_{j-1}} -1 |< \epsilon\quad\textbf{and}\quad|1- \frac{\nu_j}{\nu_{j-1}}|< \epsilon$ \textbf{then} \textbf{return}; \label{lanczos_converge}
\STATE $\textbf{q}_{j+1}= \textbf{r}_j/\beta_j$;\quad $j=j+1$;
\ENDWHILE
\end{algorithmic}
\end{algorithm}

这个算法需要$\textbf{A}$ 是正定对称矩阵。海洋模式POP中直接得到的系数矩阵是负定对称矩阵，此时只需将方程两边同时乘以单位矩阵和-1，即可将系数矩阵转换成正定对称矩阵。 


\section{试验方法和结果分析}
\label{sec:verifyExp}

\section{本章小结}
\label{sec:verifyConclusion}




