\section{Barotropic solver} \label{se:baro}
 

 


For reference, the ChronGear method is provided in Algorithm
\ref{alg:pcg}.  ChronGear contains three major parts: computation,
boundary updating, 和 global reduction.  Computation involves
matrix-vector 和 vector-vector multiplications 和 vector scaling,
all of which exhibit good scalability.  The cost of the boundary communication, which
is required to update the halo area after the matrix-vector
multiplication, is bounded 和 not problematic at the target core counts.  We will however illustrate in the subsequent section, that cost of the global reduction, which is required by the inner product in step \ref{pcg_global1} does however become problematic at large core counts.

%The boundary communication that is required to update the halo area after the matrix-vector multiplication is also non-problematic as the amount of communication required is bounded. The most time-consuming part is the global reduction process required by the inner product in step \ref{pcg_global1}.

%----------------------------------------------------------------------------
\subsection{Communication bottleneck}\label{se:bottleneck}
Assume $p=m^2$ processes are used, 和 each process has exactly one
grid block (a typical choice for high-resolution POP). Then the total time of the barotropic mode is equal to the
execution time of the ChronGear solver on any block.  For each solver
iteration, we choose $\mathcal{T}_c$, $\mathcal{T}_b$ 和
$\mathcal{T}_g$ to be the cost of the computation, boundary
updating, 和 global reduction, respectively.
%----------------------------------------------------------------------------


From Algorithm \ref{alg:pcg}, the computational cost,
$\mathcal{T}_c$, contains four vector-scaling operations (steps
\ref{pcg_scale1}, \ref{pcg_scale2} ,\ref{pcg_scale3}, 和
\ref{pcg_scale4}), two vector-vector multiplication operations for
inner products (steps \ref{pcg_dot1} 和 \ref{pcg_dot2}), 和 one
matrix-vector multiplication (step \ref{pcg_mat}).  Therefore,
$\mathcal{T}_c= (4 n^2 +2n^2+ 9n^2)\theta + \mathcal{T}_{p}
=15\frac{\mathcal{N}^2}{p}\theta+\mathcal{T}_{p}$, where $\theta$ is
the time unit per floating-point operation 和 $\mathcal{T}_{p}$ is
the cost of preconditioning.  For example, $\mathcal{T}_{p} =
\frac{\mathcal{N}^2}{p}\theta$ for a diagonal preconditioner. When the
number of processes increases, $\mathcal{T}_c$ decreases 和 has a
lower limit of zero.

Boundary updating occurs in the halo regions for each process, after
operations like matrix-vector multiplication 和 non-diagonal
preconditioning, which require one or more boundary layers.
Because every process keeps its own block 和 two extra
halo layers in POP,  only one boundary update is needed per
iteration even when a non-diagonal preconditioner is used.
The actual time depends on the network delay 和 the volume of the
halo regions.  With a halo size of $2$, the volume in each boundary
is $2n$ 和 decreases as the number of processes increases.
%It is worth mentioning that the preconditioning process usually requires at least one boundary layer,
%except for the diagonal preconditioner, which means that values on the outmost points are not updated after preconditioning.
The total boundary updating time for each iteration is then $\mathcal{T}_b =4\alpha +(4\times 2n)\beta=4\alpha +(\frac{8\mathcal{N}}{\sqrt{p}})\beta $,
where $\alpha$ is point-to-point communication latency per message 和
$\beta$ is the transfer time per byte (inverse of b和width).
The boundary updating time also decreases as the number of processes increases but has a lower bound of $4\alpha$.


ChronGear contains only one global reduction per iteration which contains a MPI\_allreduce 和 a masking operation to exclude l和 points,  thus the global
reduction time satisfies $\mathcal{T}_g= 2\frac{\mathcal{N}^2}{p}\theta + \log p \alpha$ (assuming that
a binomial tree approach is used).  The cost of the masking operation should decrease with the number of processes $p$ while the cost of the MPI\_allreduce should monotonically increase.
%The expression $\mathcal{T}_g$ should therefore initially decrease followed by a monotonic increase with process count.
Note that the global
reduction has virtually no data exchange since there are only two
numbers from each process.
%Let $T_0$ be the time unit of one floating-point operation 和 $B$ be the number of floating-point numbers transmitted by the network per second from process to process.
%Provided that the processor frequency 和 network b和width are $S_{cpu}$ 和 $B_{net}$, 和 that their efficiencies are $R_{cpu}$ 和 $R_{net}$, then $T_0 = R_{cpu} S_{cpu}^{-1}$, 和 $B = \frac{1}{8}R_{net}B_{net}$.
Combining all three components, the execution time of one diagonal preconditioned ChronGear solver step can be expressed as:
\begin{eqnarray}
%\begin{tabular}{l}
\label{t_pcg}
&\mathcal{T}_{cg}=\mathcal{K}_{cg} (\mathcal{T}_c + \mathcal{T}_b+\mathcal{T}_g )\nonumber \\
&=\mathcal{K}_{cg} [18 \frac{\mathcal{N}^2}{p}\theta + \frac{8\mathcal{N}}{\sqrt{p}}\beta +(4+\log p)\alpha]
%\end{tabular}
\end{eqnarray}
where $K_{cg}$ is the number of iterations,
%in one ChronGear step
which
does not change with the number of processes \cite{hu2013scalable}.
Equation (\ref{t_pcg}) shows that the time required for computation
和 boundary updating decreases as the number of processes increases.
But the time required for the global reduction increases with increasing
numbers of processes. Therefore, we expect the execution time of the
ChronGear solver to increase when the number of processors exceeds a
certain threshold.
Figure \ref{fig:ChronGearCOMP} gives timings for the global reduction 和
boundary (halo) updating components of
the ChronGear solver for one simulation day on the Yellowstone machine at
NCAR (machine details given in Section \ref{se:exp}).
%Indeed, the scaling behavior of ChronGear in the
%0.1\degree POP is consistent with the above analysis
%(Figure \ref{fig:ChronGearCOMP}).
Note that the execution time of global reduction
becomes dominant 和 increases when more than a couple thous和 cores are used.


\begin{figure}[!t]
%\vspace{-10pt}
\begin{center}
	\includegraphics[height=6.5cm]{newChronGear_comp.eps}
\end{center}
\vspace{-.2in}
\caption[] {Timing for the global reduction 和 halo updating components of the ChronGear
  solver in 0.1\degree\space POP for one simulation day on Yellowstone.}
\label{fig:ChronGearCOMP}
\vspace{-.1in}
\end{figure}
%However,it still inherits the poor scalability from PCG.
%We tested the diagonal preconditioned ChronGear solver in  0.1\degree POP, 和 found that the scaling behavior is consistent with the above analysis. As shown in Fig.\ref{fig:ChronGearCOMP}, the execution time of global reduction becomes dominates in the ChronGear solver 和 increases when more than 2634 cores are used.

